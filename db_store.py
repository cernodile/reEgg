# db_store.py - Providing "cloud saves" and such
import sqlite3
import db_utils
import time

# TODO: Truncate last x backups from a given device ID
def get_connection(dbName):
	con = sqlite3.connect("db/" + dbName + ".db")
	return con

def create_backups_db():
	FreshInstall = True
	con = get_connection("backups")
	cur = con.cursor()
	try:
		cur.execute("CREATE TABLE Backups(BackupID INTEGER PRIMARY KEY AUTOINCREMENT, DeviceID TEXT, BackupStamp BIGINT, ForceOffer BOOL, Payload TEXT)")
	except:
		FreshInstall = False
	con.commit()
	con.close()
	return FreshInstall

def create_contracts_db():
	FreshInstall = True
	con = get_connection("contracts")
	cur = con.cursor()
	try:
		cur.execute("CREATE TABLE Contracts(ID INTEGER PRIMARY KEY AUTOINCREMENT, CoopName TEXT, ContractName TEXT, League SMALLINT, ContractStamp BIGINT, OwnerDevice TEXT, Public BOOL, AutoGenerated BOOL)")
	except:
		FreshInstall = False
	try:
		cur.execute("CREATE TABLE ContractMember(DeviceID TEXT, CoopName TEXT, ContractName TEXT, DisplayName TEXT, LastVisit BIGINT, Contribution BIGINT, ContribRate BIGINT, SoulPower DOUBLE, BoostTokens INTEGER, TimeCheats INT, TurnedIn BOOL)")
	except:
		FreshInstall = False
	try:
		cur.execute("CREATE TABLE ContractGift(DeviceID TEXT, CoopName TEXT, ContractName TEXT, SenderName TEXT, Quantity INTEGER)")
	except:
		FreshInstall = False
	con.commit()
	con.close()
	return FreshInstall

def get_contract_info(coop_identifier, contract_name):
	if not (db_utils.is_valid_coop_or_contract(coop_identifier) or db_utils.is_valid_coop_or_contract(contract_name)):
		return None
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT * FROM Contracts WHERE CoopName="' + coop_identifier + '" AND ContractName="' + contract_name + '"')
	retval = res.fetchone()
	con.close()
	return retval

def is_coop_full(coop_identifier, contract_name, max_members):
	if not (db_utils.is_valid_coop_or_contract(coop_identifier) or db_utils.is_valid_coop_or_contract(contract_name)):
		return True
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT COUNT(DeviceID) FROM ContractMember WHERE CoopName="' + coop_identifier + '" AND ContractName="' + contract_name + '"')
	retval = res.fetchone()
	con.close()
	if retval is None:
		return False
	return retval[0] >= max_members

def get_public_coops(contract_identifier):
	if not db_utils.is_valid_coop_or_contract(contract_name):
		return []
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT CoopName FROM Contracts WHERE Public=1 AND ContractName="' + contract_identifier + '"')
	ret = res.fetchall()
	con.close()
	if ret is None:
		return []
	else:
		return ret

def change_coop_public_state(coop_identifier, contract_name, public):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	cur.execute("UPDATE Contracts SET Public=? WHERE CoopName=? AND ContractName=?", (public, coop_identifier, contract_name))
	con.commit()
	con.close()
	return True


def is_coop_identifier_used(coop_identifier, contract_name):
	if not (db_utils.is_valid_coop_or_contract(coop_identifier) or db_utils.is_valid_coop_or_contract(contract_name)):
		return True
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT League FROM Contracts WHERE CoopName="' + coop_identifier + '" AND ContractName="' + contract_name + '"')
	retval = res.fetchone()
	con.close()
	return retval[0] if retval is not None else None

def is_user_in_coop(device_id, coop_identifier, contract_name):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return None
	if not db_utils.is_valid_username(device_id):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT DeviceID FROM ContractMember WHERE DeviceID="' + device_id + '" AND CoopName="' + coop_identifier + '\" AND ContractName="' + contract_name + '"')
	x = res.fetchall()
	con.close()
	if x is None:
		return False
	else:
		return True

def create_coop_contract(coop_identifier, contract_name, league, stamp, device_id, display_name, auto_gen=False):
	if is_coop_identifier_used(coop_identifier, contract_name):
		return False
	if not db_utils.is_valid_username(device_id):
		return False
	if not db_utils.is_valid_display_name(display_name):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	stamp = int(time.time())
	cur.execute("INSERT INTO Contracts(CoopName, ContractName, League, ContractStamp, OwnerDevice, AutoGenerated) VALUES(?, ?, ?, ?, ?, ?)", (coop_identifier, contract_name, league, stamp, device_id, auto_gen))
	cur.execute("INSERT INTO ContractMember(DeviceID, CoopName, DisplayName, LastVisit) VALUES(?, ?, ?, ?)", (device_id, coop_identifier, display_name, int(time.time())))
	con.commit()
	con.close()
	return True

def get_coop_contributors(coop_identifier, contract_name):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return None
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT * FROM ContractMember WHERE CoopName="' + coop_identifier + '\" AND ContractName="' + contract_name + '"')
	x = res.fetchall()
	con.close()
	if x is None:
		return None
	else:
		return x

def update_coop_contribution(coop_identifier, contract_name, device_id, contribution, rate, soul_power, boost_tokens, cheats):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return False
	if not db_utils.is_valid_username(device_id):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	stamp = int(time.time())
	values = (int(time.time()), contribution, rate, soul_power, boost_tokens, cheats, device_id, coop_identifier, contract_name)
	cur.execute("UPDATE ContractMember SET LastVisit=?, Contribution=?, ContribRate=?, SoulPower=?, BoostTokens=?, TimeCheats=? WHERE DeviceID=? AND CoopName=? AND ContractName=?", values)
	con.commit()
	con.close()
	return True

def insert_coop_contribution(coop_identifier, contract_name, device_id, device_name, soul_power):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return False
	if not db_utils.is_valid_username(device_id):
		return False
	if not db_utils.is_valid_display_name(device_name):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	stamp = int(time.time())
	values = (device_id, contract_name, coop_identifier, device_name, int(time.time()), 0, 0, soul_power)
	cur.execute("INSERT INTO ContractMember(DeviceID, ContractName, CoopName, DisplayName, LastVisit, Contribution, ContribRate, SoulPower) VALUES(?, ?, ?, ?, ?, ?, ?, ?)", values)
	con.commit()
	con.close()
	return True

def erase_coop_contribution(coop_identifier, contract_name, device_id):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return
	if not db_utils.is_valid_username(device_id):
		return
	con = get_connection("contracts")
	cur = con.cursor()
	cur.execute("DELETE FROM ContractMember WHERE DeviceID=? AND CoopName=? AND ContractName=?", (device_id, contract_name, coop_identifier))
	con.commit()
	con.close()
	return

def get_coop_memberships(device_id):
	if not db_utils.is_valid_username(device_id):
		return None
	con = get_connection("contracts")
	cur = con.cursor()
	stamp = int(time.time())
	res = cur.execute('SELECT * FROM ContractMember WHERE DeviceID="' + device_id + '\"')
	x = res.fetchall()
	con.close()
	if x is None:
		return None
	else:
		return x

def get_coop_gifts(coop_identifier, contract_name, device_id):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return []
	if not db_utils.is_valid_username(device_id):
		return []
	con = get_connection("contracts")
	cur = con.cursor()
	res = cur.execute('SELECT * FROM ContractGift WHERE DeviceID="' + device_id + '" AND CoopName="'  + coop_identifier + '" AND ContractName="' + contract_name + '"')
	x = res.fetchall()
	cur.execute("DELETE FROM ContractGift WHERE DeviceID=? AND CoopName=? AND ContractName=?", (device_id, coop_identifier, contract_name))
	con.commit()
	con.close()
	return x

def add_coop_gift(coop_identifier, contract_name, amount, sender_name, target_id):
	if not is_coop_identifier_used(coop_identifier, contract_name):
		return False
	if not db_utils.is_valid_username(target_id):
		return False
	if not db_utils.is_valid_display_name(sender_name):
		return False
	con = get_connection("contracts")
	cur = con.cursor()
	cur.execute('INSERT INTO ContractGift(DeviceID, CoopName, ContractName, Quantity, SenderName) VALUES(?, ?, ?, ?, ?)', (target_id, coop_identifier, contract_name, amount, sender_name))
	con.commit()
	con.close()
	return True

def get_backup(ref_id):
	if not isinstance(ref_id, int):
		return None
	con = get_connection("backups")
	cur = con.cursor()
	res = cur.execute("SELECT Payload FROM Backups WHERE BackupID=" + str(ref_id))
	tuple = res.fetchone()
	con.close()
	if tuple is None:
		return tuple
	else:
		return tuple[0]

def cleanup_backups(numids):
	con = get_connection("backups")
	cur = con.cursor()
	cur.execute("DELETE FROM Backups WHERE BackupID IN(" + (", ".join(map(str, numids))) + ")")
	con.commit()
	con.close()
	return

def get_backups(device_id):
	if not device_id.isalnum():
		return []
	con = get_connection("backups")
	cur = con.cursor()
	res = cur.execute("SELECT BackupID, BackupStamp, ForceOffer, Payload FROM Backups WHERE DeviceID=\"" + device_id + "\"")
	x = res.fetchall()
	con.close()
	if x is None:
		return []
	else:
		return x

def get_last_backup(device_id):
	if not device_id.isalnum():
		return None
	con = get_connection("backups")
	cur = con.cursor()
	res = cur.execute("SELECT BackupID, BackupStamp, ForceOffer, Payload FROM Backups WHERE DeviceID=\"" + device_id + "\" ORDER BY BackupID DESC LIMIT 1")
	x = res.fetchall()
	con.close()
	if x is None:
		return []
	else:
		return x[0]

def add_backup(device_id, b64str):
	if not device_id.isalnum():
		return
	con = get_connection("backups")
	cur = con.cursor()
	stamp = int(time.time())
	res = cur.execute("INSERT INTO Backups(DeviceID, BackupStamp, ForceOffer, Payload) VALUES(?, ?, ?, ?)", (device_id, stamp, False, b64str))
	con.commit()
	con.close()
	return

def update_backup(refID, b64str, Force):
	con = get_connection("backups")
	cur = con.cursor()
	res = cur.execute("UPDATE Backups SET ForceOffer=?, Payload=? WHERE BackupID=" + str(refID), (Force, b64str))
	con.commit()
	con.close()
	return

def offer_backup_id_to_new_device(refID, device_id):
	srcBackup = get_backup(refID)
	if srcBackup is None:
		return
	add_backup(device_id, srcBackup)
	return

# If you used my server prior to zlib saves, uncomment and run once.
#import zlib
#import base64
#def compress_to_zlib():
#	con = get_connection("backups")
#	cur = con.cursor()
#	res = cur.execute("SELECT BackupID, ForceOffer, Payload FROM Backups");
#	x = res.fetchall()
#	con.close()
#	for backup in x:
#		print(backup[0])
#		update_backup(backup[0], base64.b64encode(zlib.compress(base64.b64decode(backup[2]))), backup[1])
#compress_to_zlib()

## MANUAL TRANSFER EXAMPLE
## TODO: Admin API endpoint for this
# offer_backup_id_to_new_device(2, "f7c9c95ce5f6d06a")
